// $.evalFile("d:/repositories/tk-framework-adobe/extensions/http_server/js/ECMA/JSON-js/json2.js")#include "./JSON-js/json2.js"#strict on__OBJECT_REGISTRY = {};__WRAPPER_REGISTRY = {};__GLOBAL_SCOPE_WRAPPERS = undefined;// This adds a "unique_id" method to any object that's defined.(function() {    if ( typeof Object.prototype.unique_id == "undefined" ) {        var id = 0;        Object.prototype.unique_id = function() {            if ( typeof this.__uniqueid == "undefined" ) {                this.__uniqueid = ++id;            }            return this.__uniqueid;        };    }})();function register_object(wrapper, obj) {    if ( obj instanceof Array ) {        for ( i in obj ) {            register_object(wrapper, obj[i]);        }    }    else if ( typeof obj == 'object' || typeof obj == 'function' ) {        __OBJECT_REGISTRY[wrapper.unique_id()] = obj;        __WRAPPER_REGISTRY[wrapper.unique_id()] = wrapper;    }}function is_wrapper(obj) {    if ( obj instanceof ObjectWrapper ) {        return true;    }    else if ( obj instanceof EnumeratorWrapper ) {        return true;    }    else if ( obj instanceof FunctionWrapper ) {        return true;    }    else if ( obj instanceof MethodDescriptor ) {        return true;    }    else if ( obj['__uniqueid'] != undefined ) {        return true;    }    return false;}function prepare_arguments(params) {    prepped = [];        if ( params == undefined ) {        return prepped;    }    for ( i in params ) {        arg = params[i];        if ( arg instanceof Array ) {            prepped.push(prepare_arguments(arg));        }        else if ( is_wrapper(arg) == true ) {            prepped.push(__OBJECT_REGISTRY[arg['__uniqueid']]);        }        else {            prepped.push(arg);        }    }    return prepped;}function ArgumentDescriptor(argument) {    this.name = argument.name;    this.dataType = argument.dataType;    this.defaultValue = argument.defaultValue;    this.description = argument.description;    this.help = argument.help;    this.min = argument.min;    this.max = argument.max;}function MethodDescriptor(method) {    this.name = method.name;    this.dataType = method.dataType;    this.defaultValue = method.defaultValue;    this.description = method.description;    this.help = method.help;    this.arguments = [];    if ( method.arguments != undefined ) {        for ( i in method.arguments ) {            argument = method.arguments[i];            this.arguments.push(new ArgumentDescriptor(argument));        }    }    register_object(this, method);}function ObjectWrapper(obj) {    this.name = obj.reflect.name;    this.description = obj.reflect.description;    this.help = obj.reflect.help;    this.instanceof = obj.constructor.name;    this.properties = [];    this.methods = {};    for ( i in obj.reflect.properties ) {        prop = obj.reflect.properties[i];        this.properties.push(prop.name);    }    for ( i in obj.reflect.methods ) {        method_info = obj.reflect.methods[i];        this.methods[method_info.name] = new MethodDescriptor(method_info);    }    register_object(this, obj);}function FunctionWrapper(func, name) {    this.name = name;    this.description = "";    this.help = "";    this.instanceof = "Function";    this.properties = [];    this.methods = {};    this.arguments = [];    if ( func.arguments != undefined ) {        for ( i in func.arguments ) {            argument = func.arguments[i];            this.arguments.push(new ArgumentDescriptor(argument));        }    }    register_object(this, func);}function EnumeratorWrapper(enumerator, name) {    this.name = name;    this.description = "";    this.help = "";    this.instanceof = "Enumerator";    this.properties = [];    this.methods = {};    register_object(this, enumerator);}function rpc_new(class_name) {    // TODO: Need to figure out how to expand arguments for object    // construction in ECMA3. Sadly, tricks from more modern JS do    // not work here. Right now we only support no-argument    // construction.    var obj = new this[class_name];    return JSON.stringify(wrap_item(obj, obj.reflect.name));}function rpc_get(uid, name) {    var obj = __OBJECT_REGISTRY[uid];    var value = obj[name];    return JSON.stringify(wrap_item(value, name));}function rpc_get_index(uid, index) {    var obj = __OBJECT_REGISTRY[uid];    var value = obj[index];    return JSON.stringify(wrap_item(value, index));}function rpc_set(uid, name, value) {    var obj = __OBJECT_REGISTRY[uid];    var value = value;    if ( is_wrapper(value) ) {        value = __OBJECT_REGISTRY[value['__uniqueid']];    }    obj[name] = value;}function rpc_call(uid, params, bound_parent_uid) {    var obj = __OBJECT_REGISTRY[uid];    var wrapper = __WRAPPER_REGISTRY[uid];    var result;    var args = prepare_arguments(params);    if ( bound_parent_uid != undefined && bound_parent_uid != -1 ) {        var parent = __OBJECT_REGISTRY[bound_parent_uid];        result = parent[wrapper.name].apply(parent, args);    }    else {        result = this[wrapper.name].apply(this, args);    }    if ( result != undefined ) {        return JSON.stringify(wrap_item(result, result.reflect.name));    }    else {        return;    }}function wrap_item(item, name) {    if ( item instanceof Array ) {        var wrappers = [];        for ( i in item ) {            // TODO: Does this work? Doesn't look right to me but I don't need it            // right now anyway...            wrappers.append(wrap_item[i], wrap_item[i].reflect.name);        }        return wrappers;    }    else {        if ( typeof item == 'function' ) {            return new FunctionWrapper(item, name);        }        else if ( typeof item != 'object' ) {            return item;        }        else {            try {                return new ObjectWrapper(item);            }            catch(e) {                if ( e == "Error: Invalid enumeration value" ) {                    return new EnumeratorWrapper(item, name);                }                else {                    return new EnumeratorWrapper(item, name);                }            }        }    }}function map_global_scope() {    if ( __GLOBAL_SCOPE_WRAPPERS != undefined ) {        return JSON.stringify(__GLOBAL_SCOPE_WRAPPERS);    }    var variables = this.reflect.properties;    var functions = this.reflect.methods;    var wrappers = {};    for ( i in variables ) {        var var_name = variables[i].name;        var variable = this[var_name];        if ( variable != undefined ) {            wrappers[var_name] = wrap_item(variable, var_name);        }    }    for ( i in functions ) {        var func_name = functions[i].name;        var func = this[functions[i].name];        if ( func != undefined ) {            wrappers[func_name] = wrap_item(func, func_name);        }    }    __GLOBAL_SCOPE_WRAPPERS = wrappers;    return JSON.stringify(wrappers);}